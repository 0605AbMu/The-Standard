# 3.2.1 Web Applications

## 3.2.1.0 Introduction
Web applications are the most common type of exposer components today. They are much easier to use than other known exposer UI components in the software industry. The web software market is also much easier for an engineer to publish and update than mobile applications, making it quite attractive for newer engineers. But more importantly, web applications have a much more diverse set of technologies than mobile applications.

In this chapter, we will use Blazor technology to demonstrate implementing The Standard principles for web applications. But as I previously mentioned, The Standard is technology-agnostic, meaning it can apply to any web technology without any issues.

## 3.2.1.1 On the Map
Web applications are usually set at the other end of any system. They are the terminals that humans use to interact with the system. Let's take a look at where they are located on the map:

<br />
    <div align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147833507-03db8680-8cf3-4353-9531-844b8d057ecb.png" />
    </div>
<br />

As shown above, web applications are somewhat similar to core APIs, except that they have a different group of components in terms of visualization, such as Pages, Components, and Bases. There's an intersection between two main flows in every web application. The presentation flow and the data/business flow. Depending on where a web application lives in terms of high-level architecture, its location determines whether its backend (BFF or Backend of Frontend) is a business flow or just data flow. Let's discuss these details in the characteristics section of this chapter.

## 3.2.1.2 Charactristics
Brokers, Services, View Services, Bases, Components, and Pages. Web applications are usually six essential components. Since we've already discussed the data flow components in the Services portion of The Standard, in this section, we will discuss the UI aspect (Bases, Components, and Pages) with a slight detail about view services.

Let's discuss these characteristics here.

### 3.2.1.2.0 Anatomy
UI components consist of base components, core components and pages. They all separate the responsibility of integration, rendering, and routing users to a particular UI functionality.

Let's talk about these types in detail.

#### 3.2.1.2.0.0 Base Component
Base components are just like brokers. They are wrappers around native or external UI components. Their primary responsibility is to abstract away any hard dependency on non-local UI capability. For instance, let's say we want to offer the capability to create text boxes for data insertion/capture. The native `<input>` tag could offer this capability. But exposing or leveraging this tag in our core UI components is dangerous. Because it creates a hard dependency on non-abstract UI components, if we decide to use some 3rd party UI component at any point in time, we would need to change these native `<input>` tags across all the components that use them. That's not an optimum strategy.

Let's take a look at a visualization for base component functionality:

<br />
    <div align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147835358-efab4f2a-8fc5-4e0b-bb83-326ef1292d01.png" />
    </div>
<br />

As seen in the above example, base components will wrap an external or native UI component and then expose APIs to seamlessly and programmatically interact with that component. Occasionally, these APIs will represent parameters, functions, or delegates to interact with the component based on the business flow.

##### 3.2.1.2.0.0.0 Implementation
Let's take a look at a simple Base component for solving this problem:

```html
<input @bind-value=Value />
```

```csharp
public partial class TextBoxBase : ComponentBase
{
    [Parameter]
    public string Value {get; set;}

    public void SetValue(string value) =>
        this.Value = value;
}
```

In the code above, we wrapped the `<input>` tag with our base component `TextBoxBase` and offered an input parameter `Value` to be passed into that component so it can pass it down to the native UI element. Additionally, we provided a public function `SetValue` to allow for programmatically mimicking the user's behavior to test drive the consuming component of this base element.

##### 3.2.1.2.0.0.1 Utilization
Now, when we try to leverage this base component at the core components level, we can call it as follows:

```html
<TextBoxBase @ref=MyTextBox />
```

The `@ref` aspect will allow the backend code to interact with the base component programmatically behind the scenes to call any existing functionality.

##### 3.2.1.2.0.0.2 Restrictions
Components can only use base components. Pages may not use them, and other Base components may not use them. But more importantly, it's preferred those base components would only wrap around one and only one non-local component.

And just like Brokers, Base Components do not have any business logic. They don't handle exceptions, do any calculations, or any form of sequential, iterative, or selective business logic operations. These operations are either data-based, where they belong to view services and downstream APIs, or UI-based, where they belong to Core Components.

Base components also don't handle exceptions, they don't throw their exceptions, and they don't perform any validations.

#### 3.2.1.2.0.1 Core Component
Core components are just like services in the data flow. They are test-driven, but they are also restricted with one and only one dependency at all times. Core components leverage Base components, to perform a business-specific flow. They are less generic than Base components because they orchestrate and communicate with a very particular service for the data flow.

Here's a visualization of core components architecture:

<br />
    <div align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147836385-9e2bd7af-0199-4e7d-b50d-653e626ad0d8.png" />
    </div>
<br />

In a way, core components are UI and Data components orchestrators. They will leverage one or many Base components to construct a business-specific flow such as a student registration form, then send the signal to view services to persist that data and return responses or report errors.

Core Components are three main parts. Elements, Styles and Actions. Let's discuss these parts here:

#### 3.2.1.2.0.1.0 Elements
Elements are mainly the markup pieces you find in the `.razor` file in any component. These elements should always be of Base Components. They are the skeleton of any Core Component. These Elements may or may not expose sub-routines such as a Button Click or a reactionary routine such as Button color change on hover and so on.

Elements can be tested trough three main ways. Existence, Properties and Actions.

#### 3.2.1.2.0.1.0.0 Existence
First and foremost, we need to ensure the element is loaded and is present on the screen. This can be done in three different ways. Either by property assignment, searching by id, or searching for all types. Here's some examples:

#### 3.2.1.2.0.1.0.0.0 Property Assignment
Every Component should have a corresponding property that gets attached to the Element at runtime. For instnace, assume we have a `StudentRegistrationComponent` as follows:

```csharp
public class StudentRegistrationComponent: ComponentBase
{
    public TextBoxBase NameTextBox {get; set;}
}
```
In the above code, we defined `NameTextBox` of the same type as the Base Component that will be attached to it. Once that property is define, we will need to write a failing test that verifies that this Element exists as follows:

```csharp
public void ShouldLoadNameTextBox()
{
    // when
    this.renderedStudentRegistrationComponent =
        RenderComponent<StudentRegistrationComponent>();

    // then
    this.renderedStudentRegistrationComponent.Instance.NameTextBox
        .Should().NotBeNull();
}
```

The above test will fail. That's simply because there's no markup that corresponds to the `NameTextBox` property on rendering-time. Let's make this test pass by changing the markup in `StudentRegistrationComponent.razor` as follows:

```html
<TextBoxBase @ref=NameTextBox>
```
Now our test will pass. That's simply because the property gets dynamically instantiatied as render-time once the page loads.

#### 3.2.1.2.0.1.0.0.1 Searching by Id
Sometimes Property Assignment is not an option. There are scenarios where components load dynamically a set of nested components that we may not have access to them in design-time. In this case, searching by Id is our best option to ensure we have the right component in hand.

Here's an example. Assume we have a list of components that loads dynamically by being given an list of students. We use the student object `Id` as an identifier for every component. Our code looks as follows:

```csharp
public partial StudentListComponent : ComponentBase
{
    public List<Student> Students {get; set;}

    ....

    public void OnIntialized() =>
        Students = await this.someStudentViewService.RetrieveAllStudentsAsync();
}

```
On load - we call a view service to pull asynchronously a list of all students. Now, we need to take that list and dynamically load a nested view for each student. Let's write a failing test for this first:

```csharp
public void ShouldLoadStudentsAsync()
{
    // given
    List<Student> randomStudents = CreateRandomStudents();
    ...

    this.someStudentViewService.Setup(service =>
        service.RetrieveAllStudentAsync())
            .ReturnsAsync(randomStudents);

    // when
    this.renderedStudentListComponent =
        RenderComponent<StudentRegistrationComponent>();

    // then
    ....

    foreach(Student student in randomStudents)
    {
        StudentComponent studentComponent =
            this.renderedStudentListComponent.Find($"#{student.Id}")
                as StudentComponent;

        studentComponent.Should().NotBeNull();
    }
    
    ...
}
```

In the above tests, we looked for components that match the student `Id` then we verified they exists. let's make that test pass as follows:

```html
<Iterations Items="Students">
  <StudentComponent Value="@context" />
</Iterations>>
```

We use `PrettyBlazor` library to markup our iteration behavior with `<Iterations>` tag. Now our tests should pass by finding and verifying each created component once they load on the screen.

#### 3.2.1.2.0.1.0.0.2 General Search
There are scenarios where we don't have a key or an `Id` to find the element. We expect a list of "things" to load on the screen without any data or information on them. In which case we are going to have to resolve to General search mechanism where we rely on the count of the rendered components against the count that we expect as follows:

```csharp
public void ShouldLoadManyElements()
{
    // given
    int randomCount = GetRandomNumber();

    // when
    this.renderedThingsComponent =
        RenderComponent<StudentRegistrationComponent>();

    // then
    var renderedThings = this.renderedThingsComponent.Find("p");

    renderedThings.Count.Should().Be(randomCount);
}
```

The Standard advices against having unknown-typed components like these loaded on the screen as they give a lot less control for engineers to know preceisely what's going on. But in gaming scenarios this could be the only option.

#### 3.2.1.2.0.1.0.1 Properties
The other aspect that we consier when developing Core Components are the properties on these very components. These could properties on the Core Component itself or the Base Component. For instnace, we want to verify that a `LabelBase` component has the property information on it such as `First Name` or `Last Name`.

Let's start by setting up for a test.

```csharp
public class StudentRegistrationComponent: ComponentBase
{
    public LabelBase FirstNameLabel {get; set;}
}
```

In the above code, our `StudentRegistration` component has a label on the screen that is supposed to have a certain value by default for a form. Let's write a failing test for it as follows:

```csharp
public void ShouldHaveFirstNameLabel()
{
    // given
    string expectedFirstNameLabel = "First Name";

    // when
    this.renderedStudentRegistrationComponent =
        RenderComponent<StudentRegistrationComponent>();

    // then
    ...
    this.renderedStudentRegistrationComponent.Instance.FirstNameLabel.Value
        .Should().Be(expectedFirstNameLabel);

    ...
}

```

The test here will verify the label will always have the property value `First Name`. Let's make it pass.

```html
<LabelBase @ref=FirstNameLabel Value="First Name">
```
By simply doing that, now we verified the Element exists with the right Property or information on it.

The same thing applies to properties on the Core Component itself, like having view models that load on initialization then get assigned to certain base components. We will show that example shortly.

#### 3.2.1.2.0.1.0.2 Actions
Testing actions is one of the most important parts of testing any Element. We want to ensure that when a button is clicked a certain action is triggered.


##### 3.2.1.2.0.1.0 Implementation & Tests
Let's take a look at the implementation of a core component.
```csharp
public partial class StudentRegistrationComponent : ComponentBase
{
    [Inject]
    public IStudentViewService StudentViewService {get; set;}

    public StudentRegistrationComponentState State {get; set;}
    public StudentView StudentView {get; set;}
    public TextBoxBase StudentNameTextBox {get; set;}
    public ButtonBase SubmitButton {get; set;}
    public LabelBase StatusLabel {get; set;}

    public void OnIntialized() =>
        this.State == StudentRegisterationComponentState.Content;

    public async Task SubmitStudentAsync()
    {
        try
        {
            this.StudentViewService.AddStudentViewAsync(this.StudentView);
        }
        catch (Exception exception)
        {
            this.State = StudentRegisterationComponentState.Error;
        }
    }
}
```
The above code shows the different types of properties within any given component. The dependency view service maps raw API models/data into consumable UI models. And the `State` determines whether a component should be `Loading`, `Content` or `Error`. The data view model binds incoming input to one unified model, `StudentView`. And the last three are Base level components used to construct the form of registration.

Let's take a look at the markup side of the core component:

```html
<Condition Evaluation=IsLoading>
    <Match>
        <LabelBase @ref=StatusLabel Value="Loading ..." />
    </Match>
</Condition>

<Condition Evaluation=IsContent>
    <Match>
        <TextBoxBase @ref=StudentNameTextBox @bind-value=StudentView.Name />
        <ButtonBase @ref=SubmitButton Label="Submit" OnClick=SubmitStudentAsync />
    </Match>
</Condition>

<Condition Evaluation=IsError>
    <Match>
        <LabelBase @ref=StatusLabel Value="Error Occurred" />
    </Match>
</Condition>
```

We linked the references of the student registration component properties to UI components to ensure the rendering of these components and data submission execution.

A component has already loaded state and post-submission states. Let's look at a couple of tests to verify these states.

```csharp
[Fact]
public void ShouldRenderComponent()
{
    // given
    StudentRegisterationComponentState expectedComponentState =
        StudentRegisterationComponentState.Content;

    // when
    this.renderedStudentRegistrationComponent =
        RenderComponent<StudentRegistrationComponent>();

    // then
    this.renderedStudentRegistrationComponent.Instance.StudentView
        .Should().NotBeNull();

    this.renderedStudentRegistrationComponent.Instance.State
        .Should().Be(expectedComponentState);

    this.renderedStudentRegistrationComponent.Instance.StudentNameTextBox
        .Should().NotBeNull();

    this.renderedStudentRegisterationComponent.Instance.SubmitButton
        .Should().NotBeNull();

    this.renderedStudentRegistrationComponent.Instance.StatusLabel.Value
        .Should().BeNull();

    this.studentViewServiceMock.VerifyNoOtherCalls();
}
```

The test above will verify that all the components are assigned a reference property, and no external dependency calls have been made. It validates that the code in the `OnIntialized` function on the component level is validated and performing as expected.

Now, let's take a look at the submittal code validations:

```csharp
[Fact]
public void ShouldSubmitStudentAsync()
{
    // given
    StudentRegisterationComponentState expectedComponentState =
        StudentRegisterationComponentState.Content;

    var inputStudentView = new StudentView
    {
        Name = "Hassan Habib"
    };

    StudentView expectedStudentView = inputStudentView;

    // when
    this.renderedStudentRegistrationComponent =
        RenderComponent<StudentRegistrationComponent>();

    this.renderedStudentRegistrationComponent.Instance.StudentName
        .SetValue(inputStudentView.Name);

    this.renderedStudentRegistrationComponent.Instance.SubmitButton.Click();

    // then
    this.renderedStudentRegistrationComponent.Instance.StudentView
        .Should().NotBeNull();

    this.renderedStudentRegisterationComponent.Instance.StudentView
        .Should().BeEquivalentTo(expectedStudentView);

    this.renderedStudentRegistrationComponent.Instance.State
        .Should().Be(expectedComponentState);

    this.renderedStudentRegistrationComponent.Instance.StudentNameTextBox
        .Should().NotBeNull();

    this.renderedStudentRegistrationComponent.Instance.StudentNameTextBox.Value
        .Should().BeEquivalentTo(studentView.Name);

    this.renderedStudentRegisterationComponent.Instance.SubmitButton
        .Should().NotBeNull();

    this.renderedStudentRegistrationComponent.Instance.StatusLabel.Value
        .Should().BeNull();

    this.studentViewServiceMock.Verify(service =>
        service.AddStudentAsync(inputStudentView),
            Times.Once);

    this.studentViewServiceMock.VerifyNoOtherCalls();
}
```

The test above validates that on submittal, the student model is populated with the data set programmatically through the base component instance; and verifies all these components are rendered on the screen before end-users by validating each base component an assigned instance on runtime or render-time.

##### 3.2.1.2.0.1.1 Restrictions
Core components have similar restrictions to Base components because they cannot call each other at that level. There's a level of Orchestration Core Components that can combine multiple components to exchange messages but they don't render anything on their own the same way Orchestration services delegate all the work to their dependencies.

One view service corresponds to one core component, which renders one and only one view model. But Core components are also not allowed to call more than one view service. And in that, they always stay true to the view model.

View services may do their own orchestration-level work in an extremely complex flow, but we recommend keeping things at a flat level. These very same view services perform nothing but mapping and adding audit fields in addition to basic structural validations.

#### 3.2.1.2.0.2 Pages
In every web application, pages are a fundamental mandatory container component that needs to exist so end-users can navigate to them. Pages mainly hold a route, communicate a parameter from that route and combine core-level components to represent a business value.

A good example of pages is dashboards. Dashboard pages contain multiple components like tiles, notifications, headers, and sidebars with references to other pages. Pages don't hold any business logic in and of themselves, but they delegate all route-related operations to their child components.

Let's take a look at a simple page implementation:

```html
@page '/registration'

<HeaderComponent />
<StudentRegisterationComponent />
<FooterComponent />
```

Pages are much simpler than core or base components. They don't require unit testing, and they don't necessarily need a backend code. They purely reference their components without reference (unless required) and help serve that content when navigating via a route.

#### 3.2.1.2.0.3 Unobtrusiveness
For all UI components, it's a violation to include code from multiple technologies/languages on the same page. For instance, a CSS style code, C# code, and HTML markup cannot all exist in the same file. They need to separate into their own files.

The unobtrusiveness rule helps prevent cognitive pollution for engineers building UI components and makes the system much easier to maintain. That's why every component can nest its files beneath it if the IDE/Environment used for development allows for partial implementations as follows:

- StudentRegisterationComponent.razor
    - StudentRegisterationComponent.razor.cs
    - StudentRegisterationComponent.razor.css

The node file here, `.razor` file, has all the markup needed to kick off the component's initialization. At the same time, both nested files are supporting files for simple UI logic code and styling. This level of organization (especially in Blazor) doesn't require any referencing for these nested/support files but may not be the case for other technologies, so I urge engineers to do their best to fit that model/Standard.

#### 3.2.1.2.0.4 Organization
All UI components are listed under a Views folder in the solution. Let's take a look:

- Views
    - Bases
    - Components
    - Pages

This tri-nature conforming organization should make it easier to shift reusable components and make it also easier to find these components based on their categories. I will leave it up to the engineers' preference to determine whether to break down these components further by folders/namespaces or leave them all at the same level, given the nesting is in place.